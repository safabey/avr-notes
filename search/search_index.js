var __index = {"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Home","text":"AVR Assembly Quick Notes"},{"location":"index.html#welcome","title":"Welcome!","text":"<p>Hello there!</p> <p>This site started as my own learning notebook while studying AVR Assembly. Over time, I hope it will grow into a more organized resource that others might also benefit from.</p> <p>I tried to make the content simple, structured, and practical:</p> <ul> <li>Basics of AVR architecture</li> <li>Handy code examples</li> <li>Explanations of most instructions</li> <li>Extra notes and diagrams I prepared</li> </ul> <p>Think of this as a mix between study notes and a cheat-sheet\ud83d\ude05. If you find it helpful, feel free to leave comments and share your ideas!</p> <p>Special thanks to RJH Coding and the Wikimedia community for providing open resources, such as the Arduino &amp; ATmega328P pinout diagram.</p> <p>\u26a0\ufe0f Still under development \u26a0\ufe0f</p> Ahmet Safa BA\u015eARA \u00a9 2025"},{"location":"about.html","title":"About","text":"<p>This site was created as a personal learning project while studying AVR Assembly Programming. What started as self-study notes gradually turned into a structured resource that also others might benefit from.</p> <p>The goals of this projects are:</p> <ul> <li>To write and share what I have learned about AVR</li> <li>To learn how to design, publish a static website</li> <li>To contribute to the open-source community, because I benefited from similar resources while learning C++</li> </ul>"},{"location":"about.html#about-me","title":"About Me","text":"<p>I am a medical student at Marmara University. And I have strong interest in computer programming, embedded systems and old-retro things :D</p> <p>Some people told me I shouldn\u2019t have chosen medical school because of my hobbies \u2014 but no way! I love medicine just as much, and I enjoy combining both worlds.</p>"},{"location":"about.html#communication","title":"Communication","text":"<p>Feel free to ask questions or contribute \u2014 I will answer whenever I have the time and knowledge.</p> <p>You can easily reach me through the comment section avaliable below each page.</p>"},{"location":"blink.html","title":"Blink","text":"An Example: Blink"},{"location":"blink.html#code","title":"Code","text":"<pre><code>  .include \"m328Pdef.inc\"\n\n  .def    mask    = r16\n  .def    ledR    = r17\n  .def    oLoopR  = r18\n  .def    iLoopRl = r24\n  .def    iLoopRh = r25\n\n  .equ    oVal    = 71\n  .equ    iVal    = 28168\n\n  .cseg\n  .org    0x00\n\n  ; set PINB5 to output\n  clr   ledR\n  ldi   mask, (1&lt;&lt;PINB5)\n  out   DDRB, mask\n\nstart:\n  eor   ledR, mask ; toggle PINB0 in ledRegister\n  out   PORTB, ledR ; write LedRegister to PortB\n\n  ldi   oLoopR, oVal ; initialize outer Loop count\n\noLoop:\n  ldi   iLoopRl, LOW(iVal)\n  ldi   iLoopRh, HIGH(iVal) ; initialize inner Loop count\n  ; LOW and HIGH give us lower and upper part of the value\n  ; Done by assembler, not hardware\n\niLoop:\n  sbiw    iLoopRl, 1\n  brne    iLoop\n\n  dec   oLoopR\n  brne  oLoop\n\n  rjmp    start\n</code></pre>"},{"location":"blink.html#code-analyze","title":"Code Analyze","text":""},{"location":"blink.html#def","title":"::<code>.def</code>","text":"<p>We can use <code>.def</code> directive to give registers names that we can remember easly. </p> <pre><code>.def    mask = r16\n; alias for r16 with 'mask'\n</code></pre>"},{"location":"blink.html#equ","title":"::<code>.equ</code>","text":"<p>Like <code>.def</code> directive we can use <code>.equ</code> for give names to constant values.</p> <pre><code>.equ    oVal = 71\n; alias for 71 with oVal\n</code></pre>"},{"location":"blink.html#detailed-analyze","title":"Detailed Analyze","text":""},{"location":"instructions.html","title":"All Instructions","text":"All Instructions"},{"location":"instructions.html#arithmatic-instructions","title":"Arithmatic Instructions","text":"Mnemonic Description Cycles Flags <code>add</code> add without carry 1 Z,C,N,V,H <code>adc</code> add with carry 1 Z,C,N,V,H <code>adiw</code> add immediate to word 2 Z,C,N,V,S <code>sub</code> subtract without carry 1 Z,C,N,V,H <code>subi</code> subtract immediate 1 Z,C,N,V,H <code>sbc</code> subtract with carry 1 Z,C,N,V,H <code>sbci</code> subtract immediate with carry 1 Z,C,N,V,H <code>sbiw</code> subtract immediate from word 2 Z,C,N,V,S <code>inc</code> increment 1 Z,N,V <code>dec</code> decrement 1 Z,N,V <code>mul</code> multiply unsigned * 2 Z,C <code>muls</code> multiply signed * 2 Z,C <code>mulsu</code> multiply signed with unsigned * 2 Z,C <code>fmul</code> fractional multiply unsigned * 2 Z,C <code>fmuls</code> fractional multiply signed * 2 Z,C <code>fmulsu</code> fractional multiply signed with unsigned * 2 Z,C"},{"location":"instructions.html#logic-instructions","title":"Logic Instructions","text":"Mnemonic Description Cycles Flags <code>and</code> logical AND 1 Z,N,V <code>andi</code> logical AND with immediate (with constant) 1 Z,N,V <code>or</code> logical OR 1 Z,N,V <code>ori</code> logical OR with immediate 1 Z,N,V <code>eor</code> exclusive OR (ya da) 1 Z,N,V <code>com</code> one's complement 1 Z,C,N,V <code>neg</code> two's complement 1 Z,C,N,V,H"},{"location":"instructions.html#bit-instructions","title":"Bit Instructions","text":"Mnemonic Description Cycles Flags <code>sbr</code> set bit(s) in register 1 Z,N,V <code>cbr</code> clear bit(s) in register 1 Z,N,V <code>ser</code> set register 1 - <code>clr</code> clear register 1 Z,N,V <code>swap</code> swap nibbles 1 - <code>lsl</code> logical shift left 1 Z,C,N,V <code>lsr</code> logical shift Right 1 Z,C,N,V <code>rol</code> rotate left through carry 1 Z,C,N,V <code>ror</code> rotate right through carry 1 Z,C,N,V <code>asr</code> arithmetic shift right 1 Z,C,N,V <code>tst</code> test for zero or minus 1 Z,N,V <code>sbi</code> set bit in I/O register 2 - <code>cbi</code> clear bit in I/O register 2 - <code>bset</code> flag set 1 SREG <code>bclr</code> flag clear 1 SREG <code>bst</code> bit store from register to T 1 T <code>bld</code> bit load from T to register 1 - <code>sec</code> set carry 1 C <code>clc</code> clear carry 1 C <code>sen</code> set negative flag 1 N <code>cln</code> clear negative flag 1 N <code>sez</code> set zero flag 1 Z <code>clz</code> clear zero flag 1 Z <code>sei</code> global interrupt enable 1 I <code>cli</code> global interrupt disable 1 I <code>ses</code> set signed test flag 1 S <code>cls</code> clear signed test flag 1 S <code>sev</code> set two's complement overflow 1 V <code>clv</code> clear two's complement overflow 1 V <code>set</code> set T in SREG 1 T <code>clt</code> clear T in SREG 1 T <code>seh</code> set half carry flag in SREG 1 H <code>clh</code> clear half carry flag in SREG 1 H"},{"location":"instructions.html#branch-instructions","title":"Branch Instructions","text":"Mnemonic Description Cycles Flags <code>rjmp</code> relative jump &gt; limited to \u00b1 2K words from current pos** 2 - <code>ijmp</code> indirect jump to Z 2 - <code>jmp</code> direct jump &gt; limitless jump** 2 - <code>rcall</code> relative subroutine call 3 - <code>icall</code> indirect call to Z 3 - <code>call</code> direct subroutine call 4 - <code>ret</code> subroutine return 4 - <code>reti</code> interrupt return 4 I <code>cpse</code> compare, skip if equal 1/2/3 - <code>cp</code> compare 4 Z,N,V,C,H <code>cpc</code> compare with carry 1 Z,N,V,C,H <code>cpi</code> compare register with immediate 1 Z,N,V,C,H <code>sbrc</code> skip if bit in register cleared &gt; if (Rr (b) = 0) PC** 1/2/3 - <code>sbrs</code> skip if bit in register is set &gt; if (Rr (b) = 1) PC** 1/2/3 - <code>sbic</code> skip if bit in I/O register cleared &gt; if (P (b) = 0) PC** 1/2/3 - <code>sbis</code> skip if bit in I/O register is set &gt; if (P (b) = 1) PC** 1/2/3 - <code>brbc</code> branch if status flag cleared &gt; if (SREG(s) = 0) then PC** 1/2 - <code>brbs</code> branch if status flag is set &gt; if (SREG(s) = 1) then PC** 1/2 - <code>brne</code> branch if not equal &gt; if (Z = 0) then PC** 1/2 - <code>breq</code> branch if equal &gt; if (Z = 1) then PC** 1/2 - <code>brcc</code> branch if carry cleared &gt; if (C = 0) then PC** 1/2 - <code>brcs</code> branch if carry set &gt; if (C = 1) then PC** 1/2 - <code>brsh</code> branch if same or higher &gt; if (C = 0) then PC** 1/2 - <code>brlo</code> branch if lower &gt; if (C = 1) then PC** 1/2 - <code>brmi</code> branch if minus &gt; if (N = 1) then PC** 1/2 - <code>brpl</code> branch if plus &gt; if (N = 0) then PC** 1/2 - <code>brge</code> branch if greater or equal, signed &gt; if (N \u2295 V = 0) then PC** 1/2 - <code>brlt</code> branch if less than zero, signed &gt; if (N \u2295 V = 1) then PC** 1/2 - <code>brhs</code> branch if half carry flag set &gt; if (H = 1) then PC** 1/2 - <code>brhc</code> branch if half carry flag cleared &gt; if (H = 0) then PC** 1/2 - <code>brts</code> branch if T flag set &gt; if (T = 1) then PC** 1/2 - <code>brtc</code> branch if T flag cleared &gt; if (T = 0) then PC** 1/2 - <code>brvs</code> branch if overflow flag is set &gt; if (V = 1) then PC** 1/2 - <code>brvc</code> branch if overflow flag is cleared &gt; if (V = 0) then PC** 1/2 - <code>brie</code> branch if interrupt enabled &gt; if (I = 1) then PC** 1/2 - <code>brid</code> branch if interrupt disabled &gt; if (I = 0) then PC** 1/2 - <p><code>word</code> means 2 Bytes. So <code>rjmp</code> limited with \u00b1 4096 Byte.</p>"},{"location":"instructions.html#data-transfer-instructions","title":"Data Transfer Instructions","text":"Mnemonic Description Cycles Flags <code>mov</code> move between registers 1 - <code>movw</code> copy register word 1 - <code>ldi</code> load immediate 1 - <code>ld</code> load indirect 2 - <code>ldd</code> load indirect with displacement 2 - <code>lds</code> load direct from SRAM 2 - <code>st</code> store indirect 2 - <code>std</code> store indirect  with displacement 2 - <code>sts</code> store diretc from SRAM 2 - <code>lpm</code> load program memory 3 - <code>spm</code> store program memory - - <code>in</code> in port 1 - <code>out</code> out port 1 - <code>push</code> push register on stack 2 - <code>pop</code> pop register on stack 2 -"},{"location":"instructions.html#mcu-control-instructions","title":"MCU Control Instructions","text":"Mnemonic Description Cycles Flags <code>nop</code> no operation 1 - <code>sleep</code> sleep 1 - <code>wdr</code> watchdog reset 1 - <code>break</code> break N/A -"},{"location":"registers_arithmetic.html","title":"Arithmetic Instructions","text":"Arithmetic Instructions Mnemonic Description Cycles <code>add</code> add without carry 1 <code>adc</code> add with carry 1 <code>adiw</code> add immediate to word 2 <code>sub</code> subtract without carry 1 <code>subi</code> subtract immediate 1 <code>sbc</code> subtract with carry 1 <code>sbci</code> subtract immediate with carry 1 <code>sbiw</code> subtract immediate from word 2 <code>inc</code> increment 1 <code>dec</code> decrement 1 <code>mul</code> multiply unsigned * 2 <code>muls</code> multiply signed * 2 <code>mulsu</code> multiply signed with unsigned * 2 <code>fmul</code> fractional multiply unsigned * 2 <code>fmuls</code> fractional multiply signed * 2 <code>fmulsu</code> fractional multiply signed with unsigned * 2 <p>( <sup>*</sup> ) : means, these are not implemented in ATtiny.</p>"},{"location":"registers_arithmetic.html#addition-and-subtraction","title":"Addition and Subtraction","text":""},{"location":"registers_arithmetic.html#addition","title":"Addition","text":""},{"location":"registers_arithmetic.html#add","title":"::<code>add</code>","text":"<p><code>add</code> takes two arg. Computes their sum and stores the value int the first arg.</p> <pre><code>ldi   r16, 5\nldi   r17, 6\nadd   r16, r17\n; r16 :&gt; 5 + 6 = 11\n</code></pre>"},{"location":"registers_arithmetic.html#adc","title":"::<code>adc</code>","text":"<p>Similary, <code>adc</code> - add with carry - takes two registers as input and computes their sum, then adds carry bit if needed. This is very usefull for adding more than 8-Bit values. </p> <pre><code>; 0x1234\nldi   r16, 0x34   ; lower\nldi   r17, 0x12   ; upper\n\n; 0xABCD\nldi   r18, 0xCD   ; lower\nldi   r19, 0xAB   ; upper\n\nadd   r16, r18    ; first lower bytes, this may activates carry bit\nadc   r17, r19    ; adds upper bytes, then adds carry bit\n; r17, r16 :&gt; 0xBE01\n</code></pre>"},{"location":"registers_arithmetic.html#subtraction","title":"Subtraction","text":""},{"location":"registers_arithmetic.html#sub-sbc","title":"::<code>sub</code> &amp; <code>sbc</code>","text":"<p>Same as <code>add</code> &amp; <code>adc</code>.</p>"},{"location":"registers_arithmetic.html#sbi","title":"::<code>sbi</code>","text":"<p>Subtraction with constant.</p> <pre><code>ldi   r16, 0x05\nsbi   r16, 0x05\n; r16 :&gt; 0x00\n</code></pre> \u26a0\ufe0f REMINDER Unfortunately, there is NO immediate instruction of <code>add</code>."},{"location":"registers_arithmetic.html#inc","title":"::<code>inc</code>","text":"<p>Increase the value of register by one.</p> <pre><code>clr   r16   ; clears r16 :&gt; 0\ninc   r16   ; r16 :&gt; 1\n</code></pre>"},{"location":"registers_arithmetic.html#dec","title":"::<code>dec</code>","text":"<p>Decrease the value of register by one.</p> <pre><code>clr   r16   ; clears r16 :&gt; 0\ninc   r16   ; r16 :&gt; 1\ndec   r16   ; r16 :&gt; 0\n</code></pre>"},{"location":"registers_arithmetic.html#adiw-sbiw","title":"::<code>adiw</code> &amp; <code>sbiw</code>","text":"<p>These instructions allow us to operate on 16-Bit values. Needs 2 Cycle. Allows you to add a constant value of the range 0 - 63 to the register pair.</p> <p>X ( r26 : r27 ) , Y ( r28 : r29 ) , Z ( r30 : r31 ) If only one register is specified the compiler will automatically fill in the next ( i.e. r24 \u2192 r25:r24 ).</p> <pre><code>;  Load 0x1000 into two register\nldi   r24, 0x00\nldi   r25, 0x10\nadiw    r24, 0x0A   ; add 0x0A to r24:r25 (result = 0x100A)\n\n;  Load 0x8080 into two register\nldi   XL, 0x80\nldi   XH, 0x80\nadiw    X, 1    ; increment X pointer (result = 0x8081)\n\n;  Load 0x55AA into two register\nldi   YL, 0xAA\nldi   YH, 0x55\nsbiw    Y, 0x10   ; subtract 0x10 from Y (result = 0x559A) \n</code></pre> \u26a0\ufe0f REMINDER <code>adiw</code> and <code>sbiw</code> can only be used on the registers from r24 through r31. Also, they will only work on register pairs for which the lower is an even number, i.e. r25:r24 are valid operands, but r26:r25 are not."},{"location":"registers_arithmetic.html#multiplication","title":"Multiplication","text":"<p>ATtiny family has no hardware multiplication instruction.</p>"},{"location":"registers_arithmetic.html#mul","title":"::<code>mul</code>","text":"<p><code>mul</code> allows us to compute unsigned product of any 32 register. Result needs two register. Result always be stored in r1 for upper and r0 for lower bytes.</p> <pre><code>ldi   r16, 0x18   ; 22\nldi   r17, 0x37   ; 55\nmul   r16, r17    ; r1:r0 :&gt; 0x0528 = 1210\n</code></pre>"},{"location":"registers_arithmetic.html#muls","title":"::<code>muls</code>","text":"<p><code>muls</code> allows us to compute signed product of only r16 through r31. Signed arg must be in Two's Complement format.</p> <pre><code>ldi   r16, 0xF2   ; -14 in Two's Complement\nldi   r17, 0x37   ; -33 in Two's Complement\nmul   r16, r17    ; r1:r0 :&gt; 0x01CE = 462\n</code></pre> \u2753 QUICK CHEAT To convert a value to Two's Complement format, simply add 256 if it is less than zero. <code>-14 + 256 = 242 (0xF2) in Two's Comp.: -14</code>"},{"location":"registers_arithmetic.html#mulsu","title":"::<code>mulsu</code>","text":"<p><code>mulsu</code> allows us to compute product of two arg when one of them is signed and the second one is unsigned. But some limitations, there are. It works only on r16 through r23. </p>"},{"location":"registers_arithmetic.html#fractional-multiplication","title":"Fractional Multiplication","text":"<p>ATmega supports limited multiplication of fractional numbers. Fractional number between [0,2) can be presented by an 8-Bit number in a 1.7 Format.</p> Bit 7 Bit 6 Bit 5 Bit 4 Bit 3 Bit 2 Bit 1 Bit 0 2<sup>0</sup> 2<sup>-1</sup> 2<sup>-2</sup> 2<sup>-3</sup> 2<sup>-4</sup> 2<sup>-5</sup> 2<sup>-6</sup> 2<sup>-7</sup> 1 0.5 0.25 0.125 0.0625 0.03125 0.015625 0.0078125 <p>For example: 0b01001100 would equal 0x1 + 1x0.5 + 0x0.25 + 0x0.125 + 1x0.0625 + 1x0.03125 + 0x0.015625 + 0x0.0078125 = 0.59375 using this format.</p>"},{"location":"registers_arithmetic.html#fmul","title":"::<code>fmul</code>","text":"<p><code>fmul</code> computes the sum of two 8-bit numbers in the 1.7 format and outputs the result in r1 and r0 in a 1.15 format. In 1.15, the first bit of the higher byte represents an integer component and the rest of the bits represent fractional components. fmul will only work with r16 through r23.</p> <pre><code>ldi   r16, 0xC0   ; 1.5\nldi   r17, 0xA0   ; 1.25\nfmul  r16, r17    ; r1:r0 :&gt; 0xF000 = 1.875\n</code></pre>"},{"location":"registers_arithmetic.html#fmuls","title":"::<code>fmuls</code>","text":"<p><code>fmuls</code> is signed version of <code>fmul</code>. Range is [-1,1).</p> <pre><code>ldi   r16, 0xA0   ; -0.75\nldi   r17, 0xF0   ; -0.125\nfmuls r16, r17    ; r1:r0 :&gt; 0x0C00 = 0.04375\n</code></pre> \u2753 QUICK CHEAT To convert a fractional value to Two's Complement format, simply add 2 if it is less than zero. <code>-0.75 + 2 = 1.25 (0xA0) in Two's Comp.: -0.75</code>"},{"location":"registers_arithmetic.html#fmulsu","title":"::<code>fmulsu</code>","text":"<p>And also we have first signed, second unsigned version.</p> <pre><code>ldi   r16, 0xC0   ; -0.5\nldi   r17, 0x60   ; 0.75\nfmuls r16, r17    ; r1:r0 :&gt; 0xD000 = -0x375\n</code></pre>"},{"location":"registers_data_transfers.html","title":"Data Transfers","text":"Data transfers <p>We have 32 General purpose register (r0 - r31)</p> Mnemonic Description <code>ldi</code> load immediate <code>mov</code> copy register <code>movw</code> copy register pair"},{"location":"registers_data_transfers.html#ldi","title":"::<code>ldi</code>","text":"<p><code>ldi</code> is part of a special set of immediate instructions. Immediate instructions operate on a register and require a constant be supplied as an operand. Immediate instructions are very useful as they allow you to operate with a number you supply in the code itself.</p> <pre><code>ldi   r16, 85   ; load 85 into register 16 (decimal)\nldi   r16, $55   ; load 85 into register 16 (also hex)\nldi   r16, 0x55   ; load 85 into register 16 (hex)\nldi   r16, 0125   ; load 85 into register 16 (octal)\nldi   r16, 0b01010101   ; load 85 into register 16 (binary)\n</code></pre> \u26a0\ufe0f REMINDER Immediate instructions only work with registers 16 through 31. Trying to use them with registers 0 through 15 will result in an error."},{"location":"registers_data_transfers.html#mov","title":"::<code>mov</code>","text":"<p>The contents of one register can be copied to another register using the mov instruction. Since ldi only works on registers 16 through 31, the mov instruction is a useful way to load a constant into one of the lower 16 registers.</p> <pre><code>ldi   r16, 0x55   ; load 0x55 to r16\nmov   r0, r16   ; copy content of r16 to r0\n</code></pre> \u26a0\ufe0f REMINDER It only copies the contents to first arg, but second arg remain unchanged."},{"location":"registers_data_transfers.html#movw","title":"::<code>movw</code>","text":"<p>This allows us to operate on 16-Bit values. Allows to copy the contents of one register pair into another pair.</p> <pre><code>ldi   r16, 0x34   ; load lower byte of 0x5734 into r16\nldi   r17, 0x57   ; load upper byte of 0x5734 into r17\n\nmovw    r1:r0, r17:r16   ; copy contents of r17 to r1; r16 to r0 \n</code></pre> <p>Instead of typing all pair, just write lower byte register, it knows what have to do. :D</p> <pre><code>movw    r0, r16   ; copy contents of r17 to r1; r16 to r0\n</code></pre> \u26a0\ufe0f REMINDER Lower Byte Register should be EVEN! ( 0,2, ...) \u26a0\ufe0f REMINDER Source registers will be remain unchanged!!!"},{"location":"registers_logical.html","title":"Logical Instructions","text":"Logical Instructions Mnemonic Description <code>and</code> logical AND <code>andi</code> logical AND with immediate (with constant) <code>or</code> logical OR <code>ori</code> logical OR with immediate <code>eor</code> exclusive OR (ya da) <code>com</code> one's complement <code>neg</code> two's complement"},{"location":"registers_logical.html#and-andi-or-ori-eor","title":"::<code>and</code> || <code>andi</code> &amp; <code>or</code> || <code>ori</code> &amp; <code>eor</code>","text":"ANDOR EOR pq`or p, q`p q`or p, q`pq `eor p, q` 1111 1111 0 1001 0110 1 0100 1101 1 0000 0000 0 <pre><code>ldi   r16, 0b01010101   ; load 0x55 to r16\nandi  r16, 0b00001111\n;resultat r16:0b00000101\n\nldi   r16, 0b01010101   ; load 0x55 to r16\nori   r16, 0b00001111\n;resultat r16:0b01011111\n\nldi   r16, 0b01010101\nldi   r17, 0b11111111\neor   r16, r17\n; r17 :&gt;   0b10101010\n</code></pre> <p>We can use <code>and</code> or <code>or</code> for masking purposes!</p> \u26a0\ufe0f REMINDER Again! Immediate modes only work for r16 - r31 <p>We can clear a register with <code>eor</code>.</p> <pre><code>ldi   r16, 0b11010101\neor   r16, r16\n;   r16 :&gt; 0b00000000\n</code></pre>"},{"location":"registers_logical.html#complements-and-negatives","title":"Complements and Negatives","text":""},{"location":"registers_logical.html#com","title":"::<code>com</code>","text":"<p>Allows toggle all bits of a register!</p> <pre><code>ldi   r16, 0b11110011\ncom   r16\n;   r16 :&gt; 0b00001100\n</code></pre>"},{"location":"registers_logical.html#neg","title":"::<code>neg</code>","text":"<p>Negates a register's content</p> <pre><code>ldi   r16, 5   ; load 5 into r16\nneg   r16   ; negates r16 \n;  r16 :&gt; -5 (0xFB)\n</code></pre>"},{"location":"registers_manipulation.html","title":"Bit Manipulations","text":"Bit Manipulations Mnemonic Description Cycles sbr set bit(s) in register 1 cbr clear bit(s) in register 1 ser set register 1 clr clear register 1 swap swap nibbles 1"},{"location":"registers_manipulation.html#sbr","title":"::<code>sbr</code>","text":"<p>Second argument selects bits that will be one.</p> <pre><code>ldi   r16, 0b01000000\nsbr   r16, 0b00001111\n; r16 :&gt;   0b01001111\n</code></pre> <p>It is identical with <code>ori</code>. Assembler will generate the exact same machine code.</p>"},{"location":"registers_manipulation.html#cbr","title":"::<code>cbr</code>","text":"<p>Second argument selects bits that will be zero.</p> <pre><code>ldi   r16, 0b01001111\nsbr   r16, 0b00001111\n; r16 :&gt;   0b01000000\n</code></pre> <p>It is almost identical with <code>andi</code>. But not the same !!!</p> \u26a0\ufe0f REMINDER Even though they don't have the word immediate in the name, sbr and cbr only work on registers 16 through 31."},{"location":"registers_manipulation.html#ser","title":"::<code>ser</code>","text":"<p>Sets register's all bits on. Only work with r16 : r31</p>"},{"location":"registers_manipulation.html#clr","title":"::<code>clr</code>","text":"<p>Sets register's all bit off. Only work with r16 : r31</p> \u26a0\ufe0f REMINDER <code>ser</code> and <code>clr</code> are not actual instructions implemented in the architecture, but are provided by the assembler as aliases for other instructions."},{"location":"registers_manipulation.html#swap","title":"::<code>swap</code>","text":"<p>Allows us to swap the lower 4 Bits with the upper 4 Bits of a register.</p> <pre><code>ldi   r16, 0x0F\nswap  r16\n; r16 :&gt; 0xF0\n</code></pre>"},{"location":"registers_shifts.html","title":"Bit Shifts","text":"Bit Shifts Mnemonic Description Cycles <code>lsl</code> logical shift left 1 <code>lsr</code> logical shift Right 1 <code>rol</code> rotate left through carry 1 <code>ror</code> rotate right through carry 1 <code>asr</code> arithmetic shift right 1"},{"location":"registers_shifts.html#lsl","title":"::<code>lsl</code>","text":"<p>Performs logical bit shift to LEFT with a zero.</p> <pre><code>ldi   r16, 0b00001111\nlsl   r16   ; r16 :&gt; 0b00011110\n&lt;---\n</code></pre>"},{"location":"registers_shifts.html#lsr","title":"::<code>lsr</code>","text":"<p>Performs logical bit shift to RIGHT with a zero.</p> <pre><code>ldi   r16, 0b00001111\nlsr   r16   ; r16 :&gt; 0b0000111\n--&gt;\n</code></pre>"},{"location":"registers_shifts.html#rol","title":"::<code>rol</code>","text":"<p>Similar with <code>lsl</code>. Adds zero or one according to the carry bit (status register).</p> <pre><code>ldi   r16, 0b10101010\nldi   r17, 0b10101010\n\nlsl   r16   ; r16 :&gt; 0b01010100\nrol   r17   ; r17 :&gt; 0b01010101 adds last bit shift to first bit\n</code></pre>"},{"location":"registers_shifts.html#ror","title":"::<code>ror</code>","text":"<p>Similar with <code>lsr</code>. Adds zero or one according to the carry bit (status register).</p> <pre><code>ldi   r16, 0b10101010\nldi   r17, 0b10101010\n\nlsl   r16   ; r16 :&gt; 0b01010101\nror   r17   ; r17 :&gt; 0b01010101 adds previous first bit shift to last bit\n</code></pre>"},{"location":"registers_shifts.html#asr","title":"::<code>asr</code>","text":"<p>Without changing sign of the value, this allows us to divide the value with 2. This keeps 7<sup>th</sup> Bit unchanged. And 6<sup>th</sup> Bit will be carry bit.</p> <pre><code>ldi   r16, 0b10000001   ; -127\nasr   r16   ; r16 :&gt; 0b11000000 = -64\n</code></pre>"},{"location":"whatisAVR.html","title":"What is AVR","text":"What is AVR? <p>AVR is an 8-Bit family of microcontrollers built on the RISC architecure. They are inexpensive, relatively fast and offer some powerfull features that make them a popular choice in embedded systems and hobby projects.</p> <p>Atmel (nowadays Microchip) divided microcontrollers into several groups:</p> <ul> <li>AT90Sxxxx: Old classic AVR series, not recommended for new designs</li> <li>ATtiny: Designed for small projects. Minimal I/O, memory but aimed low power consumption</li> <li>ATmega: Same core similar to ATtiny with little differences. Also more I/O and memory</li> <li>Other Special Controllers : Dedicated purposes like LCD, USB etc. controllers</li> </ul>"}]}